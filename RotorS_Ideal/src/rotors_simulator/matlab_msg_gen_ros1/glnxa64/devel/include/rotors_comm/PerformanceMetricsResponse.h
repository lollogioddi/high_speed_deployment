// Generated by gencpp from file rotors_comm/PerformanceMetricsResponse.msg
// DO NOT EDIT!


#ifndef ROTORS_COMM_MESSAGE_PERFORMANCEMETRICSRESPONSE_H
#define ROTORS_COMM_MESSAGE_PERFORMANCEMETRICSRESPONSE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace rotors_comm
{
template <class ContainerAllocator>
struct PerformanceMetricsResponse_
{
  typedef PerformanceMetricsResponse_<ContainerAllocator> Type;

  PerformanceMetricsResponse_()
    : overshoot1(0.0)
    , overshoot2(0.0)
    , overshoot3(0.0)
    , overshoot4(0.0)
    , overshoot5(0.0)
    , overshoot6(0.0)
    , settling_time1(0.0)
    , settling_time2(0.0)
    , settling_time3(0.0)
    , settling_time4(0.0)
    , settling_time5(0.0)
    , settling_time6(0.0)  {
    }
  PerformanceMetricsResponse_(const ContainerAllocator& _alloc)
    : overshoot1(0.0)
    , overshoot2(0.0)
    , overshoot3(0.0)
    , overshoot4(0.0)
    , overshoot5(0.0)
    , overshoot6(0.0)
    , settling_time1(0.0)
    , settling_time2(0.0)
    , settling_time3(0.0)
    , settling_time4(0.0)
    , settling_time5(0.0)
    , settling_time6(0.0)  {
  (void)_alloc;
    }



   typedef double _overshoot1_type;
  _overshoot1_type overshoot1;

   typedef double _overshoot2_type;
  _overshoot2_type overshoot2;

   typedef double _overshoot3_type;
  _overshoot3_type overshoot3;

   typedef double _overshoot4_type;
  _overshoot4_type overshoot4;

   typedef double _overshoot5_type;
  _overshoot5_type overshoot5;

   typedef double _overshoot6_type;
  _overshoot6_type overshoot6;

   typedef double _settling_time1_type;
  _settling_time1_type settling_time1;

   typedef double _settling_time2_type;
  _settling_time2_type settling_time2;

   typedef double _settling_time3_type;
  _settling_time3_type settling_time3;

   typedef double _settling_time4_type;
  _settling_time4_type settling_time4;

   typedef double _settling_time5_type;
  _settling_time5_type settling_time5;

   typedef double _settling_time6_type;
  _settling_time6_type settling_time6;





  typedef boost::shared_ptr< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> const> ConstPtr;

}; // struct PerformanceMetricsResponse_

typedef ::rotors_comm::PerformanceMetricsResponse_<std::allocator<void> > PerformanceMetricsResponse;

typedef boost::shared_ptr< ::rotors_comm::PerformanceMetricsResponse > PerformanceMetricsResponsePtr;
typedef boost::shared_ptr< ::rotors_comm::PerformanceMetricsResponse const> PerformanceMetricsResponseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator1> & lhs, const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator2> & rhs)
{
  return lhs.overshoot1 == rhs.overshoot1 &&
    lhs.overshoot2 == rhs.overshoot2 &&
    lhs.overshoot3 == rhs.overshoot3 &&
    lhs.overshoot4 == rhs.overshoot4 &&
    lhs.overshoot5 == rhs.overshoot5 &&
    lhs.overshoot6 == rhs.overshoot6 &&
    lhs.settling_time1 == rhs.settling_time1 &&
    lhs.settling_time2 == rhs.settling_time2 &&
    lhs.settling_time3 == rhs.settling_time3 &&
    lhs.settling_time4 == rhs.settling_time4 &&
    lhs.settling_time5 == rhs.settling_time5 &&
    lhs.settling_time6 == rhs.settling_time6;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator1> & lhs, const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rotors_comm

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "489ff84073d2b57991c40f5769f49311";
  }

  static const char* value(const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x489ff84073d2b579ULL;
  static const uint64_t static_value2 = 0x91c40f5769f49311ULL;
};

template<class ContainerAllocator>
struct DataType< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rotors_comm/PerformanceMetricsResponse";
  }

  static const char* value(const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 overshoot1\n"
"float64 overshoot2\n"
"float64 overshoot3\n"
"float64 overshoot4\n"
"float64 overshoot5\n"
"float64 overshoot6\n"
"float64 settling_time1\n"
"float64 settling_time2\n"
"float64 settling_time3\n"
"float64 settling_time4\n"
"float64 settling_time5\n"
"float64 settling_time6\n"
"\n"
;
  }

  static const char* value(const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.overshoot1);
      stream.next(m.overshoot2);
      stream.next(m.overshoot3);
      stream.next(m.overshoot4);
      stream.next(m.overshoot5);
      stream.next(m.overshoot6);
      stream.next(m.settling_time1);
      stream.next(m.settling_time2);
      stream.next(m.settling_time3);
      stream.next(m.settling_time4);
      stream.next(m.settling_time5);
      stream.next(m.settling_time6);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PerformanceMetricsResponse_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rotors_comm::PerformanceMetricsResponse_<ContainerAllocator>& v)
  {
    s << indent << "overshoot1: ";
    Printer<double>::stream(s, indent + "  ", v.overshoot1);
    s << indent << "overshoot2: ";
    Printer<double>::stream(s, indent + "  ", v.overshoot2);
    s << indent << "overshoot3: ";
    Printer<double>::stream(s, indent + "  ", v.overshoot3);
    s << indent << "overshoot4: ";
    Printer<double>::stream(s, indent + "  ", v.overshoot4);
    s << indent << "overshoot5: ";
    Printer<double>::stream(s, indent + "  ", v.overshoot5);
    s << indent << "overshoot6: ";
    Printer<double>::stream(s, indent + "  ", v.overshoot6);
    s << indent << "settling_time1: ";
    Printer<double>::stream(s, indent + "  ", v.settling_time1);
    s << indent << "settling_time2: ";
    Printer<double>::stream(s, indent + "  ", v.settling_time2);
    s << indent << "settling_time3: ";
    Printer<double>::stream(s, indent + "  ", v.settling_time3);
    s << indent << "settling_time4: ";
    Printer<double>::stream(s, indent + "  ", v.settling_time4);
    s << indent << "settling_time5: ";
    Printer<double>::stream(s, indent + "  ", v.settling_time5);
    s << indent << "settling_time6: ";
    Printer<double>::stream(s, indent + "  ", v.settling_time6);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROTORS_COMM_MESSAGE_PERFORMANCEMETRICSRESPONSE_H
